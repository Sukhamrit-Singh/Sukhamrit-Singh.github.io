<!DOCTYPE html>
<html>
<head>
    <title>Project 3 - CS180</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            line-height: 1.8;
            color: #e0e0e0;
            background: #0a0a0a;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 80px;
        }

        h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: -1px;
            color: #ffffff;
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 1em;
            color: #808080;
            margin-bottom: 60px;
            font-weight: 400;
        }

        .author {
            color: #606060;
            margin: 10px 0;
            font-size: 1em;
        }

        h2 {
            color: #ffffff;
            font-size: 1.8em;
            font-weight: 300;
            margin: 80px 0 40px;
            letter-spacing: -0.5px;
        }

        h3 {
            color: #c0c0c0;
            font-size: 1.3em;
            font-weight: 300;
            margin: 40px 0 20px;
        }

        p {
            color: #a0a0a0;
            margin-bottom: 20px;
            line-height: 1.8;
        }

        ul, ol {
            color: #a0a0a0;
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 8px;
        }

        code {
            background: #1a1a1a;
            color: #80ff80;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: inherit;
        }

        pre {
            background: #1a1a1a;
            color: #80ff80;
            padding: 20px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: inherit;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .image-wrapper {
            margin-bottom: 20px;
        }

        .image-container {
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
            border-radius: 4px;
            transition: transform 0.2s ease;
        }

        .image-container:hover {
            transform: scale(1.02);
        }

        .image-container img {
            width: 100%;
            height: auto;
            display: block;
            opacity: 0.9;
            transition: opacity 0.2s ease;
        }

        .image-container:hover img {
            opacity: 1;
        }

        .image-caption {
            color: #ffffff;
            font-size: 0.95em;
            margin-top: 10px;
            text-align: center;
        }

        .offset-info {
            font-size: 0.85em;
            color: #606060;
            margin-top: 4px;
            text-align: center;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 40px 0;
        }

        .comparison-item {
            text-align: center;
        }

        .comparison-item img {
            width: 100%;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .comparison-label {
            color: #808080;
            font-size: 0.9em;
        }

        .algorithm-box {
            background: #1a1a1a;
            border-left: 3px solid #404040;
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .highlight {
            background: #1a1a1a;
            border-left: 3px solid #ffff00;
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 40px 0;
        }

        .results-table th {
            background: #1a1a1a;
            color: #ffffff;
            padding: 12px;
            text-align: left;
            font-weight: 400;
        }

        .results-table td {
            padding: 10px;
            border-bottom: 1px solid #2a2a2a;
            color: #a0a0a0;
        }

        .results-table tr:hover {
            background: #151515;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #1a1a1a;
            border: 1px solid #404040;
            color: #808080;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            text-decoration: none;
            transition: all 0.2s ease;
            z-index: 1000;
            font-size: 14px;
        }
        
        .back-button:hover {
            background: #2a2a2a;
            color: #ffffff;
            border-color: #606060;
        }

        .triple-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 40px 0;
        }

        .frequency-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 40px;
            }
            
            .image-grid {
                grid-template-columns: 1fr;
            }
            
            .comparison {
                grid-template-columns: 1fr;
            }

            .triple-comparison {
                grid-template-columns: 1fr;
            }
        }

        /* Math / matrix layout helpers */
        .equation {
            background: transparent;
            color: #80ff80;
            padding: 12px 6px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 6px 0;
            font-family: inherit;
            white-space: nowrap;
        }

        .matrix-block {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin: 18px 0;
        }

        .matrix-block > div {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 180px;
        }

        .matrix-block h4 {
            margin-bottom: 8px;
        }

        .equation p {
            display: block;
            text-align: center;
        }
    </style>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
    <a href="./index.html" class="back-button" title="Back to portfolio">
        <span style="font-size: 14px;">../</span>
    </a>
    
    <div class="container">
        <div style="margin-bottom: 60px;">
            <h1 style="margin-bottom: 20px;">proj3/</h1>
            <div style="margin-left: 40px;">
                <div style="margin: 8px 0;">
                    <a href="#overview" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">├── </span>
                        <span style="color: #ffffff;">overview/</span>
                        <span style="color: #606060; margin-left: 8px;">Image Warping and Mosaicing</span>
                    </a>
                </div>
                <div style="margin: 8px 0;">
                    <a href="#parta" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">├── </span>
                        <span style="color: #ffffff;">partA/</span>
                        <span style="color: #606060; margin-left: 8px;">Image Warping and Mosaicing</span>
                    </a>
                </div>
                <div style="margin: 8px 0;">
                    <a href="#a1" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">│   ├── </span>
                        <span style="color: #ffffff;">A.1/</span>
                        <span style="color: #606060; margin-left: 8px;">Shoot and Digitize Pictures</span>
                    </a>
                </div>
                <div style="margin: 8px 0;">
                    <a href="#a2" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">│   ├── </span>
                        <span style="color: #ffffff;">A.2/</span>
                        <span style="color: #606060; margin-left: 8px;">Recover Homographies</span>
                    </a>
                </div>
                <div style="margin: 8px 0;">
                    <a href="#a3" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">│   ├── </span>
                        <span style="color: #ffffff;">A.3/</span>
                        <span style="color: #606060; margin-left: 8px;">Warp the Images</span>
                    </a>
                </div>
                <div style="margin: 8px 0;">
                    <a href="#a4" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">│   └── </span>
                        <span style="color: #ffffff;">A.4/</span>
                        <span style="color: #606060; margin-left: 8px;">Blend into a Mosaic</span>
                    </a>
                </div>
                <div style="margin: 8px 0;">
                    <a href="#partb" style="color: #808080; text-decoration: none; transition: color 0.2s ease;">
                        <span style="color: #404040;">└── </span>
                        <span style="color: #ffffff;">partB/</span>
                        <span style="color: #606060; margin-left: 8px;">Feature Detection and Matching</span>
                    </a>
                </div>
            </div>
        </div>

        <h1 style="font-size: 2.5em; margin-bottom: 10px;">Image Warping and Mosaicing!</h1>
        <div style="color: #808080; margin-bottom: 40px; font-size: 1em;">CS180 Project 3: Image Warping, Mosaicing, and Feature Detection</div>

        <h2 id="overview">Overview</h2>
        <p>
            This project explores two fundamental computer vision techniques: image warping and mosaicing (Part A), 
            and feature detection and matching (Part B). In Part A, we implement homography computation from point 
            correspondences, perform inverse warping with nearest-neighbor and bilinear interpolation, and blend 
            multiple images into seamless mosaics. In Part B, we develop automatic feature detection and matching 
            algorithms to create mosaics without manual point selection.
        </p>

        <div style="background: linear-gradient(90deg, #1a1a1a 0%, transparent 100%); padding: 20px; margin: 60px -20px 40px; border-left: 3px solid #40ff40;">
            <h2 id="parta" style="margin: 0; color: #40ff40;">Part A: Image Warping and Mosaicing</h2>
            <div style="color: #808080; font-size: 0.9em; margin-top: 5px;">Manual point correspondence and homography-based image warping</div>
        </div>

        <h2 id="a1">A.1: Shoot and Digitize Pictures</h2>
        <p>
            I collected four pairs of images with projective transforms between them, each with 40-70% overlap.
            Below are the source and reference image pairs used for warping and mosaicing. Each pair was captured
            with a fixed center of projection while rotating the camera.
        </p>

        <!-- Bay -->
        <h3>Bay Scene</h3>
        <div class="comparison">
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/bay/1_source_image.jpg" alt="bay source"></div>
                <div class="image-caption">Source Image</div>
            </div>
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/bay/2_reference_image.jpg" alt="bay reference"></div>
                <div class="image-caption">Reference Image</div>
            </div>
        </div>

        <!-- Chairs -->
        <h3>Outdoor Chairs</h3>
        <div class="comparison">
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/chairs/1_source_image.jpg" alt="chairs source"></div>
                <div class="image-caption">Source Image</div>
            </div>
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/chairs/2_reference_image.jpg" alt="chairs reference"></div>
                <div class="image-caption">Reference Image</div>
            </div>
        </div>

        <!-- Downtown -->
        <h3>Downtown Scene</h3>
        <div class="comparison">
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/downtown/1_source_image.jpg" alt="downtown source"></div>
                <div class="image-caption">Source Image</div>
            </div>
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/downtown/2_reference_image.jpg" alt="downtown reference"></div>
                <div class="image-caption">Reference Image</div>
            </div>
        </div>

        <!-- Sink -->
        <h3>Kitchen Sink</h3>
        <div class="comparison">
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/sink/1_source_image.jpg" alt="sink source"></div>
                <div class="image-caption">Source Image</div>
            </div>
            <div class="image-wrapper">
                <div class="image-container"><img src="proj3/sink/2_reference_image.jpg" alt="sink reference"></div>
                <div class="image-caption">Reference Image</div>
            </div>
        </div>

        <h2 id="a2">A.2: Recover Homographies</h2>
        <p>
            For this section, I implemented the function <code>H = computeH(im1_pts, im2_pts)</code> to recover the 
            transformation matrix between a source image and its corresponding image. The mapping follows the equation:
            $p' = Hp$ where $p = [x,\; y,\; 1]^T$ represents a point in the source image and
            $p' = [x',\; y',\; 1]^T$ represents the corresponding point in the destination image.
            The goal is to estimate $H$, a $3\times 3$ matrix with 8 degrees of freedom (since one element can be fixed to 1).
        </p>

        <h3>Building the System of Equations</h3>
        <p>
            Each correspondence provides two linear equations derived from:
        </p>

        <div class="equation">
            <p>
                \begin{align*}
                    x' &= \frac{h_{11}x + h_{12}y + h_{13}}{h_{31}x + h_{32}y + 1} \\[10pt]
                    y' &= \frac{h_{21}x + h_{22}y + h_{23}}{h_{31}x + h_{32}y + 1}
                \end{align*}

            </p>
        </div>

        <p>
            Rearranging these gives a linear system in the form <strong>\(A h = b\)</strong>, where each point
            correspondence contributes two rows to $A$ and $b$. For clarity, below is the
            explicit 8-row system that results from four point correspondences (\((x_i,y_i)\) ↦ \((x'_i,y'_i)\),
            \(i=1\ldots4\)):
        </p>

        <div class="equation">
            <p>
                $$
                A = \begin{bmatrix}
                x_1 & y_1 & 1 & 0 & 0 & 0 & -x_1 x'_1 & -y_1 x'_1 \\
                0 & 0 & 0 & x_1 & y_1 & 1 & -x_1 y'_1 & -y_1 y'_1 \\
                x_2 & y_2 & 1 & 0 & 0 & 0 & -x_2 x'_2 & -y_2 x'_2 \\
                0 & 0 & 0 & x_2 & y_2 & 1 & -x_2 y'_2 & -y_2 y'_2 \\
                x_3 & y_3 & 1 & 0 & 0 & 0 & -x_3 x'_3 & -y_3 x'_3 \\
                0 & 0 & 0 & x_3 & y_3 & 1 & -x_3 y'_3 & -y_3 y'_3 \\
                x_4 & y_4 & 1 & 0 & 0 & 0 & -x_4 x'_4 & -y_4 x'_4 \\
                0 & 0 & 0 & x_4 & y_4 & 1 & -x_4 y'_4 & -y_4 y'_4 
                \end{bmatrix},\qquad
                h = \begin{bmatrix} h_{11} \\ h_{12} \\ h_{13} \\ h_{21} \\ h_{22} \\ h_{23} \\ h_{31} \\ h_{32} \end{bmatrix},\qquad
                b = \begin{bmatrix} x'_1 \\ y'_1 \\ x'_2 \\ y'_2 \\ x'_3 \\ y'_3 \\ x'_4 \\ y'_4 \end{bmatrix}
                $$
            </p>
            <p>
                $$A\,h = b$$
            </p>
        </div>

        <p>
            After stacking all n correspondences, we get an overdetermined system. Since small errors in the point matches 
            can lead to large variations in $H$, I solved this system using a <strong>least-squares</strong> 
            approach to minimize error:
        </p>

        <div class="equation">
            <p>
                $$h = (A^{T}A)^{-1}A^{T}b$$
            </p>
        </div>

        <p>
            I then appended 1.0 as the final entry of $h$ and reshaped it into a $3×3$ homography matrix $H$. 
            This normalization ensures that $H[2,2] = 1$.
        </p>
        <h3>Sink correspondence visualization, assembled system, and recovered H</h3>
        <p>Below are the source/reference images used for the sink correspondences, the assembled linear system \(A\)
        built from the eight point matches, and the final recovered homography \(H\).</p>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/sink/correspondence1_2.png" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="image-caption">Sink — Source Image (correspondence points shown)</div>
        </div>

        <div style="display: flex; gap: 40px; align-items: flex-start;">

            <!-- Left: A matrix equations -->
            <div style="display: flex; justify-content: center; align-items: flex-start; gap: 20px; width: 100%;">
                <div style="flex: 2;">
                    <h4 style="text-align: center;"> _ </h4>
                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <div style="flex: 2;">
                            <h4 style="text-align: center;">Matrix A (16×8)</h4>
                            <div class="equation">
                                <p>
                                $$
                                A = \begin{bmatrix}
                                678 & 757 & 1 & 0 & 0 & 0 & -79326 & -88569 \\
                                0 & 0 & 0 & 678 & 757 & 1 & -565452 & -631338 \\
                                1096 & 708 & 1 & 0 & 0 & 0 & -603896 & -390108 \\
                                0 & 0 & 0 & 1096 & 708 & 1 & -754048 & -487104 \\
                                907 & 732 & 1 & 0 & 0 & 0 & -346474 & -279624 \\
                                0 & 0 & 0 & 907 & 732 & 1 & -680250 & -549000 \\
                                911 & 662 & 1 & 0 & 0 & 0 & -344358 & -250236 \\
                                0 & 0 & 0 & 911 & 662 & 1 & -614925 & -446850 \\
                                846 & 630 & 1 & 0 & 0 & 0 & -263106 & -195930 \\
                                0 & 0 & 0 & 846 & 630 & 1 & -556668 & -414540 \\
                                846 & 414 & 1 & 0 & 0 & 0 & -248724 & -121716 \\
                                0 & 0 & 0 & 846 & 414 & 1 & -366318 & -179262 \\
                                655 & 401 & 1 & 0 & 0 & 0 & -34060 & -20852 \\
                                0 & 0 & 0 & 655 & 401 & 1 & -281650 & -172430 \\
                                1065 & 455 & 1 & 0 & 0 & 0 & -546345 & -233415 \\
                                0 & 0 & 0 & 1065 & 455 & 1 & -494160 & -211120
                                \end{bmatrix}
                                $$
                                </p>
                            </div>
                        </div>

                        <div style="flex: 1;">
                            <h4 style="text-align: center;">Vector b (16×1)</h4>
                            <div class="equation">
                                <p>
                                $$
                                b = \begin{bmatrix}
                                117 \\
                                834 \\
                                551 \\
                                688 \\
                                382 \\
                                750 \\
                                378 \\
                                675 \\
                                311 \\
                                658 \\
                                294 \\
                                433 \\
                                52 \\
                                430 \\
                                513 \\
                                464
                                \end{bmatrix}
                                $$
                                </p>
                            </div>
                        </div>

                        <div style="flex: 1;">
                            <h4 style="text-align: center;">Recovered Homography (H)</h4>
                            <div class="equation">
                                <p>
                                $$
                                H = \begin{bmatrix}
                                2.70952308 & 1.82219090 * 10^{-1} & -1.74977712 * 10^{3} \\
                                4.44075072 * 10^{-1} & 2.24081933 & -3.90934467 * 10^{2} \\
                                1.25176295 * 10^{-3} & 1.02030528 * 10^{-4} & 1.00000000
                                \end{bmatrix}
                                $$
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <h2 id="a3">A.3: Warp the Images</h2>
        <p>
            This part consisted of implementing inverse warping with two interpolation methods from scratch:
        </p>
        <ul>
            <li><strong>Nearest neighbor:</strong> Round source coordinates to the nearest pixel.
                <ul>
                    <li><code>warpImageNearestNeighbor(im, H)</code></li>
                </ul>
            </li>
            <li><strong>Bilinear:</strong> Weighted average of four neighboring pixels.
                <ul>
                    <li><code>warpImageBilinear(im, H)</code></li>
                </ul>
            </li>
        </ul>
        <p>
            Now that we have our homography matrix from the previous part, we can apply it on our images and be warp them. 
            I implemented two warping mechanisms, which have a key distiction when it comes to choosing pixel values, but 
            everything up until then is similar. First, I predicted the bounding box of an input image by piping the four 
            corners of the image through the computed homography matrix. From here, we get the newly projected corners for 
            the source image in the new output image, which we can use to determine the shape of the complete output mosaic. 
            Initially, the mosaic is zero-filled, meaning its a black canvas. To fill the mosaic, we have to using inverse-warping 
            to retrieve the pixel values from the original source image, and this is where the difference in the 
            nearest-neighbor and bilinear mechanisms come in.
        </p>

        <h3>Nearest Neighbor Interpolation</h3>
        <p>
            Nearest Neighbor interpolation assigns the value of the closest pixel to the computed source location. This is done by 
            taking the inverse of the homography matrix $H$ and applying it to the newly projected image as mentioned above. 
            However, when taking the inverse, the $(x, y)$ pixel values are not guaranteed to be exact integer values. To overcome this, 
            the nearest neighbor approach just takes the closest pixel to the inverse-calculated pixel, and sets the pixel value in 
            the mosaic image to the value of the closest pixel in the source image. One thing to note is the pixel value was only chosen 
            if the mapped back value was in the bounds of the source image.
        </p>
        <p>
            For example, given a pixel location $(x_m, y_m)$ in the mosaic, we first compute its corresponding location in the source image 
            using the inverse homography:
            <br>
            $$p_s = H^{-1} \, p_m = H^{-1} \, \begin{bmatrix} x_m \\ y_m \\ 1 \end{bmatrix} = 
            \begin{bmatrix} x_s' \\ y_s' \\ w \end{bmatrix},$$
        </p>
        <p>
            Since $(x_s,y_s)$ are generally not integers, the nearest neighbor method locates the pixel position by rounding:
            <br>
            $$x_{NN} = \\{round}(x_s), \\y_{NN} = \\{round}(y_s).$$
        </p>
        <p>
            Finally, the pixel value at $(x_{NN},y_{NN})$ in the source image is assigned to the mosaic pixel at $(x_m,y_m)$. This rounding-based 
            calculation, while computationally simple, results in a less smooth output compared to interpolation methods that weight nearby pixel 
            values.
        </p>

        <h3>Bilinear Interpolation</h3>
        <p>
            Bilinear interpolation computes a weighted average of the four nearest pixels based on the distance from the source location. If we 
            do the same procedure as the nearest neighbors where we take the inverse of the homography matrix and apply it on the mosaic pixel coordinate 
            pair $(x_m, y_m),$ we get the corresponding location in the source image: $(x_s, y_s).$ From here, we can apply bilinear interpolation which 
            takes the pixel values of all the 4 closest pixels around $(x_s, y_s),$ and sets the value of $(x_s, y_s)$ to be the weighted average of all 4 
            pixel values. Bilinear interpolation may require more computation than nearest neighbors, but it results in a smoother image in the end. One 
            thing to note is the pixel value was only chosen if the mapped back value was in the bounds of the source image.
        </p>

        <!-- Bilinear Interpolation Section -->
        <div style="display: flex; align-items: center; justify-content: center; gap: 40px; margin: 40px auto; width: 80%; flex-wrap: wrap;">
            
            <!-- Left: Bilinear Interpolation Image -->
            <div style="flex: 1; min-width: 300px; text-align: center;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/bilinear.png"
                        alt="Bilinear Interpolation Diagram"
                        style="max-width: 70%; height: auto; border: none; outline: none; display: block; margin: 0 auto;">
                </div>
                <div class="image-caption">Bilinear Interpolation Mapping</div>
            </div>

            <!-- Right: Equation Explanation -->
            <div style="flex: 1.2; min-width: 340px; display: flex; flex-direction: column; justify-content: center;">
                <h4 style="color: #ffffff; margin-bottom: 12px; text-align: center;">Mathematical Formulation</h4>

                <div class="equation" style="text-align: center;">
                    <p>
                        $$
                        x_1 = \lfloor x_s \rfloor,\quad x_2 = x_1 + 1,\quad
                        y_1 = \lfloor y_s \rfloor,\quad y_2 = y_1 + 1
                        $$
                    </p>
                </div>

                <div class="equation" style="text-align: center;">
                    <p>
                        $$
                        a = x_s - x_1,\qquad b = y_s - y_1
                        $$
                    </p>
                </div>

                <div class="equation" style="text-align: center;">
                    <p>
                        $$
                        \begin{aligned}
                        I(x_s, y_s) &=
                        (1 - a)(1 - b)\,I(y_1, x_1) +
                        a(1 - b)\,I(y_1, x_2) \\\\
                        &\quad + (1 - a)b\,I(y_2, x_1) +
                        a b\,I(y_2, x_2)
                        \end{aligned}
                        $$
                    </p>
                </div>

                <!-- Explanation of I(x, y) -->
                <p style="font-size: 14px; color: #cccccc; text-align: center; margin-top: 10px;">
                    <em>Note:</em> <strong>I(x, y)</strong> represents the image intensity (pixel value) at coordinates (x, y).
                </p>
            </div>
        </div>


        <p>
            Both of these approaches had their strenghts and weaknesses. The nearest neighbors approach was generally faster, less 
            computationally intensive, and less blurry than the bilinear interpolation method. However, bilinear interpolation produced  
            more smooth results due to the weighted blending of surrounding pixel values. On the images below, we can notice the differences 
            in results. For the rectified door, the shadow on the left side of the door is much more linear and smooth in bilinear interpolation. 
            In the nearest neighbors, the shadow outline is more jagged. However, in the table rectified image, the bilinear interpolation is 
            more blurry than the nearest neighbor result.
        </p>

        <!-- Door Rectification  -->
        <h3>Door Rectification</h3>

        <div class="comparison" style="display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px;">

            <!-- Original Image -->
            <div class="comparison-item" style="text-align: center; flex: 1; min-width: 260px;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/door/1_source_image.jpg" alt="Bay - Original"
                        style="max-width: 100%; height: auto; border: none; outline: none;">
                </div>
                <div class="comparison-label" style="margin-top: 8px;">Original Image</div>
            </div>

            <!-- Nearest Neighbor -->
            <div class="comparison-item" style="text-align: center; flex: 1; min-width: 260px;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/door/3_rectified_nn.jpg" alt="Bay - Nearest Neighbor"
                        style="max-width: 100%; height: auto; border: none; outline: none;">
                </div>
                <div class="comparison-label" style="margin-top: 8px;">Nearest Neighbor Interpolation</div>
                <div class="comparison-label" style="margin-top: 8px;">Time: 8.6 seconds</div>
            </div>

            <!-- Bilinear -->
            <div class="comparison-item" style="text-align: center; flex: 1; min-width: 260px;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/door/2_rectified_bilinear.jpg" alt="Bay - Bilinear"
                        style="max-width: 100%; height: auto; border: none; outline: none;">
                </div>
                <div class="comparison-label" style="margin-top: 8px;">Bilinear Interpolation</div>
                <div class="comparison-label" style="margin-top: 8px;">Time: 16.2 seconds</div>
            </div>
        </div>


        <!-- Table Rectification  -->
        <h3>Table Rectification</h3>

        <div class="comparison" style="display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px;">

            <!-- Original Image -->
            <div class="comparison-item" style="text-align: center; flex: 1; min-width: 260px;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/table/1_source_image.jpg" alt="Bay - Original"
                        style="max-width: 100%; height: auto; border: none; outline: none;">
                </div>
                <div class="comparison-label" style="margin-top: 8px;">Original Image</div>
            </div>

            <!-- Nearest Neighbor -->
            <div class="comparison-item" style="text-align: center; flex: 1; min-width: 260px;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/table/3_rectified_nn.jpg" alt="Bay - Nearest Neighbor"
                        style="max-width: 100%; height: auto; border: none; outline: none;">
                </div>
                <div class="comparison-label" style="margin-top: 8px;">Nearest Neighbor Interpolation</div>
                <div class="comparison-label" style="margin-top: 8px;">Time: 39 seconds</div>
            </div>

            <!-- Bilinear -->
            <div class="comparison-item" style="text-align: center; flex: 1; min-width: 260px;">
                <div class="image-container" style="display: flex; justify-content: center;">
                    <img src="proj3/table/2_rectified_bilinear.jpg" alt="Bay - Bilinear"
                        style="max-width: 100%; height: auto; border: none; outline: none;">
                </div>
                <div class="comparison-label" style="margin-top: 8px;">Bilinear Interpolation</div>
                <div class="comparison-label" style="margin-top: 8px;">Time: 54 seconds</div>
            </div>
        </div>

        <h2 id="a4">A.4: Blend the Images into a Mosaic</h2>
        <p>
            After warping, now its time to blend the images together, and to do this, I used weighted averaging with alpha masks. 
            The first step to doing this was computing the overall size of the combined mosaic image based on the bounding boxes of 
            the reference and warped images. Each image was also then assigned an alpha mask that takes the value of 1 near the image 
            center and decays linearly towards the edges, creating a smooth alpha mask effect. The blending process then combines both 
            images by taking the weighted sum of their overlapping regions, which is then normalized by the accumulated alpha values. 
        </p>
        
        <div class="equation" style="text-align: center;">
            <p>
                $$
                I_{\text{mosaic}}(x, y) = 
                \frac{\alpha_1(x, y)\,I_1(x, y) + \alpha_2(x, y)\,I_2(x, y)}
                    {\alpha_1(x, y) + \alpha_2(x, y)}
                $$
            </p>
        </div>

        <p style="font-size: 14px; color: #cccccc; text-align: center; margin-top: 10px;">
            <em>Note:</em> \(I_1, I_2\) are the source and warped images, and \(\alpha_1, \alpha_2\) are their corresponding alpha weights that decay toward the edges.
        </p>

        <p>    
            The 
            result is a smooth transition between overlapping regions, resulting in the final mosaic of the two images. Below are the 
            final mosaic results for each dataset, comparing nearest neighbor versus bilinear interpolation mosaics.
        </p>

        <!-- Bay Mosaics -->
        <h3>Bay Scene Mosaics</h3>
        <div class="comparison">
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/bay/1_source_image.jpg" alt="Bay Mosaic - Nearest Neighbor">
            </div>
            <div class="comparison-label">Source Image</div>
            </div>
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/bay/2_reference_image.jpg" alt="Bay Mosaic - Bilinear">
            </div>
            <div class="comparison-label">Reference Image</div>
            </div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/bay/6_mosaic_nn.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Nearest Neighbor Mosaic</div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/bay/5_mosaic_bilinear.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Bilinear Mosaic</div>
        </div>

        <!-- Chairs Mosaics -->

        <h3>Outdoor Chairs Mosaics</h3>
        <div class="comparison">
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/chairs/1_source_image.jpg" alt="Bay Mosaic - Nearest Neighbor">
            </div>
            <div class="comparison-label">Source Image</div>
            </div>
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/chairs/2_reference_image.jpg" alt="Bay Mosaic - Bilinear">
            </div>
            <div class="comparison-label">Reference Image</div>
            </div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/chairs/6_mosaic_nn.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Nearest Neighbor Mosaic</div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/chairs/5_mosaic_bilinear.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Bilinear Mosaic</div>
        </div>

        <!-- Downtown Mosaics -->
        <h3>Downtown Mosaics</h3>
        <div class="comparison">
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/downtown/1_source_image.jpg" alt="Bay Mosaic - Nearest Neighbor">
            </div>
            <div class="comparison-label">Source Image</div>
            </div>
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/downtown/2_reference_image.jpg" alt="Bay Mosaic - Bilinear">
            </div>
            <div class="comparison-label">Reference Image</div>
            </div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/downtown/6_mosaic_nn.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Nearest Neighbor Mosaic</div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/downtown/5_mosaic_bilinear.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Bilinear Mosaic</div>
        </div>

        <!-- Sink Mosaics -->
        <h3>Kitchen Sink Mosaics</h3>
        <div class="comparison">
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/sink/1_source_image.jpg" alt="Bay Mosaic - Nearest Neighbor">
            </div>
            <div class="comparison-label">Source Image</div>
            </div>
            <div class="comparison-item">
            <div class="image-container">
                <img src="proj3/sink/2_reference_image.jpg" alt="Bay Mosaic - Bilinear">
            </div>
            <div class="comparison-label">Reference Image</div>
            </div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/sink/6_mosaic_nn.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Nearest Neighbor Mosaic</div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/sink/5_mosaic_bilinear.jpg" alt="sink source" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Bilinear Mosaic</div>
        </div>

        <div style="background: linear-gradient(90deg, #1a1a1a 0%, transparent 100%); padding: 20px; margin: 60px -20px 40px; border-left: 3px solid #4080ff;">
            <h2 id="partb" style="margin: 0; color: #4080ff;">Part B: Feature Detection and Matching</h2>
            <div style="color: #808080; font-size: 0.9em; margin-top: 5px;">Automatic feature detection and matching for seamless mosaics</div>
        </div>

        <h3>B.1: Harris Corner Detection</h3>
        <p>
            I implemented the Harris corner detection algorithm following Section 2 of the Brown et al. paper. 
            The Harris detector identifies corners by analyzing local intensity variations in multiple directions. 
            I used a single-scale implementation without sub-pixel accuracy as specified in the assignment.
        </p>

        <h4>Mathematical Foundation</h4>
        <p>
            The Harris corner detector is based on the structure tensor, which measures local image structure. 
            For each pixel $(x, y)$, we compute the image gradients $I_x$ and $I_y$ using Sobel operators, then 
            build the structure tensor $M$:
        </p>

        <div class="equation">
            <p>
                $$
                M = \begin{bmatrix}
                \sum_{W} I_x^2 & \sum_{W} I_x I_y \\
                \sum_{W} I_x I_y & \sum_{W} I_y^2
                \end{bmatrix} = \begin{bmatrix}
                A & C \\
                C & B
                \end{bmatrix}
                $$
            </p>
        </div>

        <p>
            where $W$ represents a local window around the pixel. The corner response function $R$ is then computed as:
        </p>

        <div class="equation">
            <p>
                $$
                R = \det(M) - k(\text{trace}(M))^2 = AB - C^2 - k(A + B)^2
                $$
            </p>
        </div>

        <p>
            where $k$ is typically set to 0.04-0.06. Corners are identified as local maxima of $R$ above a threshold.
        </p>

        <div class="algorithm-box">
            <p><strong>Harris Corner Detection Algorithm:</strong></p>
            <ul>
                <li>Compute image gradients $I_x$ and $I_y$ using Sobel operators</li>
                <li>Build the structure tensor $M$ for each pixel in a local window</li>
                <li>Calculate the corner response $R = \det(M) - k(\text{trace}(M))^2$</li>
                <li>Apply non-maximum suppression to find local maxima</li>
                <li>Threshold the response to select strong corners</li>
            </ul>
        </div>

        <h4>Harris Corners Detection Results</h4>
        <p>Below are the detected Harris corners overlaid on the source images:</p>
        
        <div class="comparison">
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part1/1_source_image.jpg" alt="Harris Corners Image 1">
                </div>
                <div class="comparison-label">Harris Corners - Image 1</div>
            </div>
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part1/2_source_image.jpg" alt="Harris Corners Image 2">
                </div>
                <div class="comparison-label">Harris Corners - Image 2</div>
            </div>
        </div>

        <h4>Adaptive Non-Maximal Suppression (ANMS)</h4>
        <p>
            I implemented Adaptive Non-Maximal Suppression (ANMS) following Section 3 of the paper to ensure 
            well-distributed corner points across the image. ANMS selects the strongest corners while maintaining 
            a minimum distance between selected points.
        </p>

        <h4>ANMS Mathematical Formulation</h4>
        <p>
            ANMS ensures that selected corners are well-distributed by maintaining a minimum distance between them. 
            For each corner point $p_i$ with response $R_i$, we find the minimum distance to a corner with higher response:
        </p>

        <div class="equation">
            <p>
                $$
                r_i = \min_{j: R_j > R_i} \|p_i - p_j\|_2
                $$
            </p>
        </div>

        <p>
            We then select the top $N$ corners with the largest $r_i$ values, ensuring they are both strong 
            (high $R_i$) and well-distributed (large $r_i$). This creates a more uniform distribution of 
            feature points across the image.
        </p>

        <div class="comparison">
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part1/ANMS1_image.jpg" alt="ANMS Results 1">
                </div>
                <div class="comparison-label">ANMS Corners - Image 1</div>
            </div>
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part1/ANMS2_image.jpg" alt="ANMS Results 2">
                </div>
                <div class="comparison-label">ANMS Corners - Image 2</div>
            </div>
        </div>

        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/partB/part1/ANMS_overlap_image.jpg" alt="ANMS Overlap" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">ANMS Corners Overlap Visualization</div>
        </div>

        <h3>B.2: Feature Descriptor Extraction</h3>
        <p>
            I implemented feature descriptor extraction following Section 4 of the Brown et al. paper. 
            For each detected corner, I extracted axis-aligned 8x8 patches from a larger 40x40 window 
            to create well-blurred descriptors. The descriptors are bias/gain-normalized for robust matching.
        </p>

        <h4>Mathematical Formulation</h4>
        <p>
            For each corner point $(x_c, y_c)$, I extract a 40×40 window $W$ centered at the corner. 
            From this window, I sample an 8×8 descriptor patch $D$ by taking every 5th pixel:
        </p>

        <div class="equation">
            <p>
                $$
                D[i,j] = W[5i + x_c - 20, 5j + y_c - 20], \quad i,j \in \{0,1,\ldots,7\}
                $$
            </p>
        </div>

        <p>
            The descriptor is then bias/gain-normalized to make it robust to illumination changes:
        </p>

        <div class="equation">
            <p>
                $$
                \mu = \frac{1}{64}\sum_{i=0}^{7}\sum_{j=0}^{7} D[i,j], \quad \sigma = \sqrt{\frac{1}{64}\sum_{i=0}^{7}\sum_{j=0}^{7} (D[i,j] - \mu)^2}
                $$
            </p>
        </div>

        <div class="equation">
            <p>
                $$
                D_{\text{norm}}[i,j] = \frac{D[i,j] - \mu}{\sigma}
                $$
            </p>
        </div>

        <p>
            This normalization ensures that the descriptor has zero mean and unit variance, making it 
            invariant to linear illumination changes.
        </p>

        <div class="algorithm-box">
            <p><strong>Feature Descriptor Extraction Process:</strong></p>
            <ul>
                <li>Extract 40×40 window around each corner point</li>
                <li>Sample 8×8 patches from the larger window (every 5th pixel)</li>
                <li>Apply bias/gain normalization: $\mu = 0$, $\sigma = 1$</li>
                <li>Create 64-dimensional feature vectors</li>
            </ul>
        </div>

        <h4>Extracted Feature Descriptors</h4>
        <p>Below are examples of the extracted normalized 8x8 feature descriptors:</p>
        
        <div class="comparison">
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part2/img1_features_image.jpg" alt="Feature Descriptors Image 1">
                </div>
                <div class="comparison-label">Feature Descriptors - Image 1</div>
            </div>
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part2/img2_features_image.jpg" alt="Feature Descriptors Image 2">
                </div>
                <div class="comparison-label">Feature Descriptors - Image 2</div>
            </div>
        </div>

        <h3>B.3: Feature Matching</h3>
        <p>
            I implemented feature matching following Section 5 of the paper. The matching process uses 
            normalized cross-correlation to find similar feature descriptors between image pairs. I used 
            Lowe's ratio test for thresholding, comparing the ratio between the first and second nearest 
            neighbors to filter out ambiguous matches.
        </p>

        <h4>Mathematical Formulation</h4>
        <p>
            For each feature descriptor $d_i$ in image 1, I compute the normalized cross-correlation with 
            all descriptors $d_j$ in image 2:
        </p>

        <div class="equation">
            <p>
                $$
                \text{NCC}(d_i, d_j) = \frac{d_i \cdot d_j}{\|d_i\| \|d_j\|} = \frac{\sum_{k=1}^{64} d_i[k] \cdot d_j[k]}{\sqrt{\sum_{k=1}^{64} d_i[k]^2} \sqrt{\sum_{k=1}^{64} d_j[k]^2}}
                $$
            </p>
        </div>

        <p>
            Since the descriptors are normalized (zero mean, unit variance), this simplifies to:
        </p>

        <div class="equation">
            <p>
                $$
                \text{NCC}(d_i, d_j) = d_i \cdot d_j
                $$
            </p>
        </div>

        <p>
            For each feature $d_i$, I find the two best matches $d_{j_1}$ and $d_{j_2}$ with the highest 
            NCC scores. Lowe's ratio test then filters matches based on:
        </p>

        <div class="equation">
            <p>
                $$
                \text{ratio} = \frac{\text{NCC}(d_i, d_{j_2})}{\text{NCC}(d_i, d_{j_1})} = \frac{d_i \cdot d_{j_2}}{d_i \cdot d_{j_1}}
                $$
            </p>
        </div>

        <p>
            A match is accepted only if $\text{ratio} < \tau$, where $\tau$ is typically 0.7-0.8. 
            This ensures that the best match is significantly better than the second-best match.
        </p>

        <div class="algorithm-box">
            <p><strong>Feature Matching Algorithm:</strong></p>
            <ul>
                <li>Compute normalized cross-correlation: $\text{NCC}(d_i, d_j) = d_i \cdot d_j$</li>
                <li>Find nearest and second-nearest neighbors for each feature</li>
                <li>Apply Lowe's ratio test: $\text{ratio} = \frac{d_i \cdot d_{j_2}}{d_i \cdot d_{j_1}}$</li>
                <li>Accept matches where $\text{ratio} < \tau$ (typically $\tau = 0.7$)</li>
            </ul>
        </div>

        <h4>Feature Matching Results</h4>
        <p>Below are the matched features between image pairs:</p>
        
        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/partB/part3/feature_matching_image.jpg" alt="Feature Matching Results" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Matched Features Between Image Pairs</div>
        </div>

        <h3>B.4: RANSAC for Robust Homography</h3>
        <p>
            I implemented 4-point RANSAC from scratch to compute robust homography estimates from 
            the matched features. RANSAC (Random Sample Consensus) is essential for handling outliers 
            in feature matches and ensuring reliable homography computation.
        </p>

        <h4>Mathematical Formulation</h4>
        <p>
            RANSAC iteratively estimates the homography by randomly sampling minimal point sets and 
            evaluating the quality of the resulting model. For each iteration:
        </p>

        <div class="equation">
            <p>
                $$
                \text{Error}(p_i, p'_i, H) = \|p'_i - H p_i\|_2
                $$
            </p>
        </div>

        <p>
            where $p_i$ and $p'_i$ are corresponding points, and $H$ is the homography matrix. 
            A point is considered an inlier if its error is below a threshold $\epsilon$:
        </p>

        <div class="equation">
            <p>
                $$
                \text{inlier} \Leftrightarrow \|p'_i - H p_i\|_2 < \epsilon
                $$
            </p>
        </div>

        <p>
            The algorithm runs for $N$ iterations, where $N$ is computed based on the expected 
            outlier ratio and desired confidence:
        </p>

        <div class="equation">
            <p>
                $$
                N = \frac{\log(1 - p)}{\log(1 - (1 - \epsilon)^s)}
                $$
            </p>
        </div>

        <p>
            where $p$ is the desired confidence (e.g., 0.99), $\epsilon$ is the outlier ratio, 
            and $s$ is the minimum number of points needed to fit the model (4 for homography).
        </p>

        <div class="algorithm-box">
            <p><strong>4-Point RANSAC Algorithm:</strong></p>
            <ul>
                <li>Randomly sample 4 point correspondences</li>
                <li>Compute homography $H$ from the 4 points using least squares</li>
                <li>Count inliers: $\|p'_i - H p_i\|_2 < \epsilon$</li>
                <li>Repeat for $N$ iterations, keeping best $H$</li>
                <li>Refine $H$ using all inliers with least squares</li>
            </ul>
        </div>

        <h4>RANSAC Results</h4>
        <p>Below are the RANSAC results showing robust homography computation:</p>
        
        <div class="comparison">
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part4/chair_RANSAC_image.jpg" alt="Chair RANSAC Results">
                </div>
                <div class="comparison-label">Chair Scene - RANSAC Results</div>
            </div>
            <div class="comparison-item">
                <div class="image-container">
                    <img src="proj3/partB/part4/sink_RANSAC_image.jpg" alt="Sink RANSAC Results">
                </div>
                <div class="comparison-label">Sink Scene - RANSAC Results</div>
            </div>
        </div>

        <h4>Automatic Mosaic Creation</h4>
        <p>
            Using the automatically detected and matched features with RANSAC, I created mosaics 
            without manual point selection. The system computes homographies from the matched features 
            and applies the same warping and blending techniques from Part A.
        </p>

        <h4>Comparison: Manual vs Automatic Stitching</h4>
        <p>Below are comparisons between manually stitched mosaics (from Part A) and automatically stitched mosaics (from Part B):</p>
        
        <div style="width: 70vw; margin: 0 auto; text-align: center;">
            <div class="image-container">
                <img src="proj3/partB/part4/sink_mosaic_image.jpg" alt="Sink Automatic Mosaic" style="width: 100%; height: auto;">
            </div>
            <div class="comparison-label">Sink Scene - Automatic Mosaic</div>
        </div>

        <h4>Additional Automatic Mosaics</h4>
        <p>Below are additional automatic mosaics created using the feature detection and matching pipeline:</p>
        
        <div class="image-grid">
            <div class="image-wrapper">
                <div class="image-container">
                    <img src="proj3/partB/other_images/chair_mosaic_image.jpg" alt="Chair Automatic Mosaic">
                </div>
                <div class="image-caption">Chair Scene - Automatic Mosaic</div>
            </div>
            <div class="image-wrapper">
                <div class="image-container">
                    <img src="proj3/partB/other_images/dt_mosaic_image.jpg" alt="Downtown Automatic Mosaic">
                </div>
                <div class="image-caption">Downtown Scene - Automatic Mosaic</div>
            </div>
            <div class="image-wrapper">
                <div class="image-container">
                    <img src="proj3/partB/other_images/scene_mosaic_image.jpg" alt="Scene Automatic Mosaic">
                </div>
                <div class="image-caption">General Scene - Automatic Mosaic</div>
            </div>
        </div>

        <div class="highlight">
            <p><strong>Key Results:</strong> The automatic feature detection and matching pipeline successfully 
            creates high-quality mosaics comparable to manual stitching. RANSAC effectively handles outliers 
            in feature matches, ensuring robust homography computation. The system demonstrates the power 
            of automated computer vision techniques for image stitching applications.</p>
        </div>

        <div style="text-align: center; color: #606060; margin-top: 80px; padding: 40px 0; border-top: 1px solid #2a2a2a;">
            © 2025 Sukhamrit Singh. All rights reserved.
        </div>
        </div>
    </body>
    </html>
